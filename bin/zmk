#! /bin/bash

unset LANG

sln=PowerUp.sln
confdir=${XDG_CONFIG_HOME:-$HOME/.config}/zmk
config=${confdir}/zmk.config
os=$(uname -s | tr [:upper:] [:lower:])

[ -d "$confdir" ] || mkdir -p "$confdir"
[ -f "$config" ] && source "$config"

function die()
{
    echo "$@"
    exit 1
}

function trace()
{
    echo "$*"
}

function debug()
{
#    echo "$*"
    :
}

function save-config()
{
    cat >$config <<END
target=$target
dest=$dest
END
}

function split()
{
	old_ifs=$IFS
	IFS=$1; shift
	string=$1; shift
	eval "read $* <<< '$string'"
	IFS=$old_ifs
}

function use-target()
{
	target=$1

	if [ -z "$target" ]; then
		die "Target is not set"
	fi

	old_ifs=$IFS
	IFS='-'
	read mso platform mode <<< "$target"
	IFS=$old_ifs

	case $target in
		*-c5320-*|*-samsung-*|*-humax-*|*-humaxwb-*)
			cpu=mips;;
		*-samsung4k-*|*-humax4k-*)
			cpu=arm;;
		*) die "Unknown CPU $target";;
	esac
}

function mksymbols()
{
	builddir=../output/${platform}-${cpu}-${mso}/${mode}
	symdir=../symbols/${platform}-${cpu}-${mso}/${mode}

	mkdir -p ${symdir}
	for i in $builddir/*.sym; do
		read module os arch hash name < <(head -n1 $i)
		mkdir -p ${symdir}/$name/$hash/
		cp -u $i ${symdir}/$name/$hash/
	done
}

function gensymbols-stripped()
{
	local builddir=$1
	local symdir=$2

	mkdir -p ${symdir}
	for i in $builddir/*; do
		type=$(file $i)
		local sym=$i.sym
		local target=$symdir/${i##*/}
		local name
		local hash

		if [[ $type =~ executable|shared\ object ]]; then
			if [ "$i" -nt "$sym" ]; then
				echo "Generate symbols $i => $sym"
#				mipsel-linux-strip -s $i
				dump_syms $i 2> >(grep -v 'file contains no debugging information') > $sym
			fi

			read module os arch hash name < <(head -n1 $sym)
#			echo "cp -vu $sym ${symdir}/$name/$hash/ (" $(head -n1 $sym) ")"
			mkdir -p ${symdir}/$name/$hash/
			cp -u $sym ${symdir}/$name/$hash/
		fi
	done
}

function mksymbols-stripped()
{
	builddir=../output/${platform}-${cpu}-${mso}/${mode}
	osdir=../osdir/${platform}-${cpu}-${mso}
	symdir=../symbols/${platform}-${cpu}-${mso}/${mode}

	gensymbols-stripped $builddir $symdir
	gensymbols-stripped $osdir $symdir
}

function stackwalk()
{
	local name
#	mksymbols
#	ls -l ../symbols/${platform}-${cpu}-${mso}/${mode}
	case $1 in
	*.gz) gunzip $1; name=${1%%.gz};;
	*) name=$1;
	esac
    
#	minidump_stackwalk $name ../symbols/${platform}-${cpu}-${mso}/${mode} 2> $name.info | grep -v "[a-z][a-z0-9] = \|Found by:" | mipsel-linux-c++filt > $name.text
	minidump_stackwalk $name ../symbols/${platform}-${cpu}-${mso}/${mode} 2> $name.info > $name.text
}

function show-status()
{
	local i
	case $scope in
	world)
		for i in *; do
			if [ -d "$i/.svn" ]; then
				echo "[svn] $i"
				(cd $i && svn status)
			elif [ -d "$i/.git" ]; then
				echo "[git] $i"
				(cd $i && git status -s)
			elif [ -d "$i" ]; then
				echo "skip $i"
			fi
		done
		;;

	*)
		i=$(pwd)
		local n=${i##*/}
		if [ -d ".svn" ]; then
			echo "[svn] $n"
			svn status
		elif [ -d ".git" ]; then
			echo "[git] $n"
			git status
		else
			echo "skip $n"
		fi
		;;
	esac
}

function checkout()
{
	local svn_rev
	local git_rev

	if [[ "$1" =~ ([0-9]+)-([0-9]+)-([0-9]+) ]]; then
		local year=${BASH_REMATCH[1]}
		local month=${BASH_REMATCH[2]}
		local day=${BASH_REMATCH[3]}

		svn_rev="{$year-$month-$day}"
		git_rev="{$year-$month-$day 00:00:00}"
	else
		die "Unvalid date specification '$1'"
	fi

	cat solution | grep -v "^#" | while read build repo branch; do
		if [ -z "$repo" ]; then
			continue
		fi

		local dir=${build%%/*}
		pushd $dir > /dev/null || die "Unable to open dir: $dir"
		echo [$dir]

		if [ -d .svn ]; then
			svn update -r "$svn_rev"
		elif [ -d .git ]; then
			eval "$branch"
			git checkout "$BRANCH@$git_rev"
		else
		    die "unknown vcs: $dir"
		fi
		popd > /dev/null
	done
}

function common-prefix()
{
	local n=0
	local x=$((${#1}<${#2}?${#1}:${#2}))
	local s=0
#	echo -ne $x:
	while [[ ($n -lt $x) && ("${1:n:1}" == "${2:n:1}") ]]; do
		if [[ ${1:n:1} == '/' ]]; then
			s=$n
		fi
		((n++))
#		echo -ne "[$n ${1:n:1}" "${2:n:1}]"
	done
	echo "${1:0:$s}"
}

function realpath()
{
#    pushd "$1" | cut -d ' ' -f 1
    cd "$1" && pwd
}


function build-sln-entry()
{
    local dir=$1
    local target=$2

    if [ "$dryrun" != "yes" ]; then
	(
		cd $dir
		echo Build $dir
		bash ./make.sh $target || exit 1
	) || return 1
	else
		echo "build $target in $dir"
	fi
}

function build-solution()
{
	local X
	local TEMP
	local params
	local build
	local curdir=$(realpath $1)/
	local slndir=$(pwd)
	local dir
	local build_prefix=0
	local target=$2

	declare -A params
	declare -A build
	[ -f solution ] || die "'solution' file is not found"

	if [[ $scope = "project" ]]; then
		# save one level of directory from curdir
		curdir=${curdir#$slndir/}   # strip $slndir from the left
		curdir=${curdir%%/*}        # strip all the path names from the right, except first one
		curdir=${slndir}/${curdir}/ # combine the upper level project name
	fi

	while read a || [ -n "$a" ]; do
		params=()
		[ "${a:0:1}" != "#" ] || continue
		debug
		read -ra INFO <<< "$a"
		params[DIR]="${INFO[0]}"
		dir="${INFO[0]}"
		unset INFO[0]
		for i in "${INFO[@]}"; do
			case $i in
			PARAMS=*)
				IFS=',' read -ra TEMP <<< "${i#PARAMS=}"
				for j in "${TEMP[@]}"; do
					IFS=':' read -ra X <<< "${j}"
					params[${X[0]}]=${X[1]}
				done
				;;
			*)
				IFS='=' read -ra TEMP <<< "$i"
				params[${TEMP[0]}]=${TEMP[1]}
				;;
			esac
		done

		debug "check solution line: '$a'"
		debug "dir: $dir"
		for i in "${!params[@]}"; do
			debug "$i -> ${params[$i]}"
		done

		if [ -n "${params[dontbuild]+abc}"  ]; then
			debug "dontbuild flag is set, do not build"
			continue
		fi

		if [ "${params[os]:-$os}" != "$os" ]; then
			debug "OS doesn't match (curent: $s, expected ${params[os]}), do not build"
			continue
		fi

		dir="${params[copath]:-$dir}"
		if [ ! -d "$dir" ]; then
			debug "target path doesn't exist"
			continue
		fi

		case $scope in
		world)
			build[${#build[*]}]="$dir"
			continue
			;;
		esac

		dir=$(realpath $dir)/
		prefix=$(common-prefix $dir $curdir)
		n=${#prefix}
		debug "check  '$dir'"
		debug "curdir '$curdir'"
		debug "slndir '$slndir'/${#slndir}"
		debug "prefix '$prefix'/${n}"

		if [[ "$dir" = "$prefix" ]]; then	# full match
			debug "exact match"
			if ! build-sln-entry $dir  $target; then
				exit 1
			fi
			return;
		fi

		# check for partial match
		if [ $n -lt ${#slndir} ]; then
			debug "match in another dir, do not build"
			continue
		fi

		## append to build queue
		if [ $n -lt $build_prefix ]; then
			debug "match is shorter, do not build"
			continue;
		fi

		if [ $n -gt $build_prefix ]; then
			debug "found longer match, reset queue"
			build_prefix=$n
			build=()
		fi

		build[${#build[*]}]="$dir"
		debug "append $dir to queue"

	done < solution

	for i in "${build[@]}"; do
		if ! build-sln-entry $i $target; then
			exit 1
		fi
	done

}

function make-sh()
{
    case $1 in
    build)
		build-solution $curdir $2 || exit 1
#		bash ./make.sh $2 || exit 1
		if [ "$scope" == "world" ]; then
			if [ "$mode" == "dbg" ]; then
			    mksymbols
			else
			    mksymbols-stripped
		    fi
		fi
		;;
    clean)      bash ./make.sh clean-$2 ;;
    rebuild)    make-sh clean $2 && make-sh build $2;;
    update)     cd ../.. && ./vcs.sh update;;
    set-config) save-config;;
    get-config) echo $2;;
    bt)         for i in $bt; do stackwalk $i; done ;;
    status)	show-status;;
    upload)	make-sh build $2 && zupload $2 ;;
    checkout)	checkout $checkout_date;;
    *)          echo Action is not supported; exit 1 ;; 
    esac
}

function push-list()
{
	local name="$1"
	local value="$2"

	if [ -z "${!name}" ]; then
		eval $name="$value"
	else
		eval "$name='${!name} $value'"
	fi
}

echo "*** make using Zodiac build system"

while test $# -ne 0; do
    i=$1
    shift

    case "$i" in
	--clean|--build|--rebuild|--resend)
		action=${i:2}
		;;

	clean|build|rebuild|resend)
		action=${i}
		;;

	--mod|-mod|-c|m|module)
		scope="module"
		;;

	--prj|-prj|-p|p|prj|project)
		scope="project"
		;;

	--world|-world|-w|world|w)
		scope="world"
		;;

	u|upload)
		scope="world"
		action=upload
		;;

	--module|--world|--upload|--project)
		scope=${i:2}
		;;

	update|--update)
		scope=world
		action=update
		;;

	bt)
		scope=world
		push-list action "$i"
		i=$1
		shift
		push-list bt $(pwd)/$i
		;;

	set-config|--set-config)
		scope=world
		push-list action "set-config"
		;;

	get-config|--get-config)
		scope=world
		push-list action "get-config"
		;;

	status)
		action=$i
		scope=project
		;;

	wstatus)
		scope=world
		action=${i:1}
		;;

	checkout)
		checkout_date=$1
		shift
		action=$i
		;;

	--dry-run|-n)
		dryrun=yes
		;;

	--*|-*)
		echo "Unknown option $i";
		exit 1
		;;

	*)	push-list ctarget "$i"
		;;

    esac

done

if [ -n "$ctarget" ]; then
	target="$ctarget"

elif [ -z "$target" ]; then
	target=cvc-c5320-dev
#	target=cvc-humax-dev
fi

if [ -z "$action" ]; then
	action=build
fi


if [ -z "$scope" ]; then
	if [ -f "$sln" -o -f "apps/$sln" -o -f "native/apps/$sln" ]; then
	    scope="world";
	else
	    scope="module"
	fi
fi

case $scope in
world)
	makefile=PowerUp.sln
	build=make-sh
	dir_list="native/apps apps ../apps"
	echo "*** build world ***"
	;;

module)
	makefile=solution
	build=make-sh
	echo "*** build module ***"
	;;

project)
	makefile=PowerUp.sln
	build=make-sh
	echo "*** build project ***"
	;;

esac

curdir=$(pwd)
p=$(pwd)
while [ "$p" != "/" ]; do
	if [ -f $p/$makefile ]; then
		found=yes
		break 1
	fi
	for dir in $dir_list; do
		if [ -f $p/$dir/$makefile ]; then
			found=yes
			p=$p/$dir
			break 2
		fi
	done
	p=`dirname $p`
done

#curdir=${curdir#$p/}
echo slndir: $p
echo curdir: $curdir

if [ ! -f "$p/$makefile" ]; then
	echo "$makefile not found"
	exit 1
fi

echo "Using dir: $p"
cd $p

# export ENABLE_DEBUG_SYMBOLS=1
#export LDFLAGS=-g
#export CFLAGS=-g
#export CXXFLAGS=-g

echo "Build $scope $target"
for t in $target; do
    use-target $t
    for i in $action; do
	$build $i $t || exit 1
    done
done
